#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Cosmic Clipboard Manager
A lightweight GTK3 frontend for cliphist, designed for COSMIC/Wayland.
"""

import sys
import subprocess
import os
import signal
import fcntl
import gi

gi.require_version('Gtk', '3.0')
gi.require_version('GdkPixbuf', '2.0')
from gi.repository import Gtk, Gdk, GdkPixbuf

LOCK_FILE = "/tmp/cosmic_clipboard.lock"

def acquire_lock_or_toggle():
    """
    Ensures single instance. If already running, signals the other instance to exit (toggle behavior).
    """
    lock_fd = open(LOCK_FILE, 'a+')
    try:
        # Try to acquire an exclusive lock (non-blocking)
        fcntl.flock(lock_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
        # Write current PID
        lock_fd.seek(0)
        lock_fd.truncate()
        lock_fd.write(str(os.getpid()))
        lock_fd.flush()
        # Keep file open to hold lock
        return lock_fd
    except BlockingIOError:
        # Locked by another instance
        try:
            lock_fd.seek(0)
            content = lock_fd.read().strip()
            if content:
                # Toggle: Kill the running instance
                os.kill(int(content), signal.SIGTERM)
        except (ValueError, ProcessLookupError, OSError):
            pass
        # Exit this instance
        sys.exit(0)

# Run toggle logic immediately
_lock_handle = acquire_lock_or_toggle()

class ClipboardWindow(Gtk.Window):
    def __init__(self):
        super().__init__(title="Clipboard")
        self.set_default_size(500, 450)
        self.set_position(Gtk.WindowPosition.CENTER)
        self.set_icon_name("cosmic-clipboard-manager")
        self.set_wmclass("cosmic-clipboard-manager", "CosmicClipboardManager")
        self.set_keep_above(True)
        self.present()

        # Layout
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.add(vbox)

        # Scrollable area
        scrolled = Gtk.ScrolledWindow()
        scrolled.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        vbox.pack_start(scrolled, True, True, 0)

        # Data Store: Thumbnail (Pixbuf), Text (str), ID (str)
        self.store = Gtk.ListStore(GdkPixbuf.Pixbuf, str, str)
        self.populate_store()

        # TreeView
        self.tree = Gtk.TreeView(model=self.store)
        self.tree.set_headers_visible(False)
        
        # Column 1: Icon/Image
        px_renderer = Gtk.CellRendererPixbuf()
        px_renderer.set_property("xalign", 0.5) 
        px_column = Gtk.TreeViewColumn("Image", px_renderer, pixbuf=0)
        px_column.set_fixed_width(40)
        self.tree.append_column(px_column)

        # Column 2: Text
        tx_renderer = Gtk.CellRendererText()
        tx_renderer.set_property("ellipsize", 3) # Ellipsize at end
        tx_renderer.set_property("xpad", 10)
        tx_renderer.set_property("ypad", 8)
        tx_column = Gtk.TreeViewColumn("Text", tx_renderer, text=1)
        tx_column.set_alignment(0.0)
        self.tree.append_column(tx_column)

        # Signal connections
        self.tree.connect("button-press-event", self.on_button_press)
        self.tree.connect("row-activated", self.on_row_activated)
        self.connect("key-press-event", self.on_key_press)
        self.connect("focus-out-event", self.on_focus_out)

        scrolled.add(self.tree)
        self.show_all()

    def get_thumbnail(self, id_val, text_preview):
        """Generates a thumbnail for binary/image entries using cliphist decode."""
        if "[[ binary data" in text_preview:
            try:
                cmd = ["cliphist", "decode", id_val]
                data = subprocess.check_output(cmd, stderr=subprocess.DEVNULL)
                
                loader = GdkPixbuf.PixbufLoader()
                loader.write(data)
                loader.close()
                pixbuf = loader.get_pixbuf()
                
                if pixbuf:
                    h = pixbuf.get_height()
                    w = pixbuf.get_width()
                    target_h = 32
                    scale = target_h / float(h)
                    new_w = int(w * scale)
                    
                    if h > target_h:
                        return pixbuf.scale_simple(new_w, target_h, GdkPixbuf.InterpType.BILINEAR)
                    return pixbuf
            except Exception:
                pass
        return None

    def populate_store(self):
        # Load System Icons
        trash_icon = None
        text_icon = None
        try:
            icon_theme = Gtk.IconTheme.get_default()
            trash_icon = icon_theme.load_icon("user-trash-symbolic", 24, 0)
            text_icon = icon_theme.load_icon("text-x-generic-symbolic", 24, 0)
        except Exception:
            pass

        # Add "Clear History" option
        self.store.append([trash_icon, "Clear History", "CLEAR"])
        
        try:
            # Fetch cliphist items
            cmd = "cliphist list | head -n 25"
            output = subprocess.check_output(cmd, shell=True).decode("utf-8")
            
            for line in output.splitlines():
                parts = line.split('\t', 1)
                if len(parts) == 2:
                    id_val = parts[0]
                    text_val = parts[1]
                    stripped = text_val.strip()
                    
                    # Filter broken/binary text entries (null bytes)
                    if '\x00' in text_val:
                        continue

                    # Filter short garbage
                    if len(stripped) < 2: 
                        continue
                    
                    # Filter file paths to avoid duplicates for images
                    if stripped.startswith("/") and stripped.lower().endswith(('.png', '.jpg', '.jpeg', '.webp', '.bmp')):
                        continue

                    # Try to get thumbnail
                    thumb = self.get_thumbnail(id_val, text_val)
                    
                    if thumb:
                        # Image row: Show thumbnail, empty text
                        self.store.append([thumb, "", id_val])
                    elif "[[ binary data" in text_val:
                        # Binary without thumbnail: Skip
                        continue
                    else:
                        # Text row: Show text icon, text
                        self.store.append([text_icon, text_val, id_val])
        except Exception:
            pass

    def execute_action(self, id_val):
        if id_val == "CLEAR":
            # Execute wipe in background and notify
            os.system("nohup sh -c 'echo y | cliphist wipe' >/dev/null 2>&1 &")
            os.system("nohup notify-send 'Clipboard' 'History Cleared' >/dev/null 2>&1 &")
            os._exit(0)
        else:
            # Decode item to clipboard
            cmd = f"cliphist decode {id_val} | wl-copy"
            subprocess.run(cmd, shell=True)
            os._exit(0)

    def on_button_press(self, widget, event):
        # Handle single click (Button 1) manually
        if event.type == Gdk.EventType.BUTTON_PRESS and event.button == 1:
            path_info = self.tree.get_path_at_pos(int(event.x), int(event.y))
            if path_info:
                path, col, cx, cy = path_info
                model = self.tree.get_model()
                iter_ = model.get_iter(path)
                id_val = model.get_value(iter_, 2)
                self.execute_action(id_val)
                return True
        return False

    def on_row_activated(self, tree, path, column):
        # Handle keyboard (Enter) activation
        model = tree.get_model()
        iter_ = model.get_iter(path)
        id_val = model.get_value(iter_, 2)
        self.execute_action(id_val)

    def on_key_press(self, widget, event):
        if event.keyval == Gdk.KEY_Escape:
            os._exit(0)

    def on_focus_out(self, widget, event):
        os._exit(0)

if __name__ == "__main__":
    win = ClipboardWindow()
    win.connect("destroy", Gtk.main_quit)
    Gtk.main()